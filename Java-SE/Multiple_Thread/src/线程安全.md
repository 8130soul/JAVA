                                    线程安全问题
问题出现的原因：
当某个线程执行过程中，尚未完成执行，其他线程也参与进来，进行操作
~~~~![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 "GitHub,Social Coding"）
~~~~
解决：
当a线程在执行操作时，任何线程不得参与进来，直到a线程执行完所有操作完，其他线程才能进行操作（即使线程a进入阻塞状态）

**在JAVA中，通过同步机制来解决线程的安全问题
方式一：同步代码块**
    **synchronized（同步监视器）｛
        //需要同步的代码
    ｝**
同步监视器，即锁。任何一个类的对象，都可以充当锁。
要求：多个线程必须共用同一个锁。

说明：操作共享数据的代码（同步代码）
    在继承Thread类创建多线程中，慎用this充当同步监视器，可以考虑当前类充当监视器
    在实现Runnable方法创建多线程中，可以考虑使用this充当同步监视器。

**方式二：同步方法**
    如果操作共享数据的代码完整地声明在一个方法中，可以将这个方法变为同步方法
    **public synchronized void 方法名**    这里   同步监视器就是this
    注意：在继承Thread类创建多线程中，由于监视器就是this，而对象有多个，所以此时未成功同步；
        加上 static关键字后，解决问题  此时  监视器就是当前类   类名.class

总结：1.同步方法仍然涉及到同步监视器，只是不需要**显式声明**
     2._非静态同步方法，同步监视器：**this**
       静态同步方法，同步监视器：**当前类本身**
       
**方式三:Lock锁**
    采用**ReentrantLock对象**
    面试题：**synchronized和lock**的**异同**
        同：两者都可以解决线程安全问题
        异：synchronized机制在执行完同步代码后，自动释放同步监视器
           lock机制需要手动启动同步，手动结束同步
           
**优先使用顺序：
    Lock->同步代码块->同步方法** 


**创建线程的方法**    
新增方式一:实现callable接口
    FutureTask 
    1.call方法可以有返回值
    2.call方法可以抛出异常，被外面的操作捕获，获取异常的信息
    3.callable支持泛型
    
新增方式二:使用线程池
    1.提高了响应速度，减少了创建新线程的时间
    2.降低资源消耗，重复利用线程池中的线程，不需要每次创建线程
    3.便于线程管理
        corePoolSize:核心池的大小
        maximumPoolSize:最大线程数
        keepAliveTime:线程没有任务时最多保持多长时间后会终止
        
    
       
       
附加：
单例模式：单例模式的关键就是在系统运行期间，**某个类有且只有一个实例**，这种设计模式的最大优点在于可以对资源进行重复利用，
节约重复创建和销毁的成本，从而降低服务器压力，提高程序的运行效率。

懒汉和饿汉的区别：
    饿汉的特点是加载类比较慢（由于加载类的时候需要加载累的对象，比较慢），但是获取对象的速度比较快，**线程安全**；
    懒汉的特点是加载类比较快，但是获取对象的速度比较慢，**线程不安全**；
    
    
    
                                            **线程通信**

1.线程通信涉及到的3个方法：
1）wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器；
2）notify():一旦执行此方法，就会唤醒wait的一个线程，如果有多个线程wait，就唤醒优先级最高的那个。
3）notifyall():一旦执行此方法，就会唤醒所有被wait的线程。

2.说明：
1）wait()、notify()、notifyall()三个方法必须使用在**同步代码块**或**同步方法**中；
2）wait()、notify()、notifyall()三个方法的调用者必须是**同步代码块或同步方法中的同步监视器**。否则会出现IllegaMonitorStateException异常。
3）wait()、notify()、notifyall()三个方法是定义在**java.lang.Object**类中。

面试题：**sleep（）和wait（）的异同**
1.同:一旦执行方法，线程进入阻塞状态
2.异:
    1) 声明的位置不同:Thread类中声明sleep(),Object类中声明wait()
    2) 调用的要求不同:sleep()可以在任何需要的场景下调用，wait()只能在同步代码块或同步方法中使用
    3) sleep()方法不会释放同步监视器,wait()方法会释放同步监视器




